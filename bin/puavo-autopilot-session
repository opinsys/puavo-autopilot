#!/usr/bin/ruby1.9.1

# puavo-autopilot-session
#
# Simulates system use by starting some programs and doing crazy things.
# Takes no command line arguments, but can (and must) be configured with
# tags from Puavo.
# See README for more information.

require 'json'

# actions

def click_mouse
  system('xte', 'mouseclick 1')
end

def firefox(page)
  system('firefox', '-new-window', page)
end

def kill_current_window
  system('xte', 'keydown Alt_L', 'key F4', 'keyup Alt_L')
  press_enter()
end

def kill_kill_kill
  16.times do
    move_mouse_somewhere()
    click_mouse()
    kill_current_window()
    press_enter()
  end
end

def logout
  system('gnome-session-quit', '--force', '--no-prompt', '--logout')
end

def move_mouse(x_dist, y_dist)
  x = (x_dist / 20.0).to_i
  y = (y_dist / 20.0).to_i
  r = 0.0

  while r <= 1 do
    system('xte', "mousermove #{ x } #{ y }")
    sleep(0.02)
    r += 0.05
  end
end

def move_mouse_somewhere
  x = (rand() * 800).to_i - 400
  y = (rand() * 600).to_i - 300
  move_mouse(x, y)
end

def press_enter
  system('xte', 'key Return')
end

def write_line(line)
  system('xte',
	 * line.chomp.split('').map { |s| "key #{ s }" },
	 'key Return')
end

# other functionality

def get_autopilot_mode
  conffile_path = ENV['PUAVO_SESSION_PATH']
  conf = JSON.parse( IO.read(conffile_path) )["device"]

  if not conf.has_key?('tags') then
    puts "No tags defined in #{ conffile_path }"
    return ''
  end

  # Mode must match user, so we check out autopilot tags and find the mode
  # for this user.  If the mode is not found nothing gets done.
  # This is also needed so that ordinary users can login to hosts
  # (especially ltspservers) and use the system in a normal way.

  autopilot_tags = conf['tags'].select { |s| s.match(/^autopilot/) }

  available_modes = %w(smoke stress)
  mode            = ''

  autopilot_tags.each do |autopilot_tag|
    autopilot_string, maybe_mode, username, password \
      = * autopilot_tag.split(':')

    if autopilot_string != 'autopilot'                                  \
         || maybe_mode.nil? || (! available_modes.include?(maybe_mode)) \
         || username.nil?   || username.empty?                          \
         || password.nil?   || password.empty? then
      warn "Autopilot tag '#{ autopilot_tag }' is not sensible."
      next
    end

    if username == ENV['USER']
      # found the mode we where looking for.
      mode = maybe_mode
      break
    end
  end

  mode
end

def get_random_command_string(sum, commands_with_cumulative_probability)
  random_number = rand() * sum
  commands_with_cumulative_probability.reverse.each do |cmdinfo|
    if random_number >= cmdinfo[0]
      return cmdinfo[1]
    end
  end

  raise 'Internal error on get_random_command'
end

mode = get_autopilot_mode()

if mode == 'smoke' then
  begin
    require 'net/http'
    require 'uri'

    log_uri = URI.parse('http://localhost:8888/puavo-autopilot.smoke')
    log_json = JSON.generate({'msg' => 'begin-user-session'})
    Net::HTTP.post_form(log_uri, {'json' => log_json})
  ensure
    exit(logout())
  end
end

if mode != 'stress' then
  exit 0
end

while true do
  spacechar = ' '
  loadavg = IO.read('/proc/loadavg').split(spacechar).first.to_f

  commands = [
    [ 60, %q{ move_mouse_somewhere()                                }, ],
    [ 20, %q{ click_mouse()                                         }, ],
    [ 20, %q{ press_enter()                                         }, ],
    [ 30, %q{ write_line('humppaa')                                 }, ],

    [ 6,  %q{ firefox('http://areena.yle.fi/')                      }, ],
    [ 6,  %q{ firefox('http://www.amazon.com/')                     }, ],
    [ 6,  %q{ firefox('http://www.apple.com/')                      }, ],
    [ 6,  %q{ firefox('http://www.bing.com/')                       }, ],
    [ 15, %q{ firefox('http://www.facebook.com/')                   }, ],
    [ 6,  %q{ firefox('http://www.google.com/')                     }, ],
    [ 3,  %q{ firefox('http://www.redhat.com/')                     }, ],
    [ 3,  %q{ firefox('http://www.ubuntu.com/')                     }, ],
    [ 6,  %q{ firefox('http://www.yahoo.com/')                      }, ],
    [ 9,  %q{ firefox('http://www.youtube.com/')                    }, ],
    [ 3,  %q{ firefox('http://www.youtube.com/watch?v=mahBZ4lSZHQ') }, ],
    [ 3,  %q{ firefox('http://www.youtube.com/watch?v=S1Lz8b3w618') }, ],

    [ 3,  %q{ system('gimp')                                        }, ],
    [ 3,  %q{ system('khangman')                                    }, ],

    [ 3,  %q{ system('libreoffice', '--base'   )                    }, ],
    [ 2,  %q{ system('libreoffice', '--calc'   )                    }, ],
    [ 2,  %q{ system('libreoffice', '--draw'   )                    }, ],
    [ 2,  %q{ system('libreoffice', '--impress')                    }, ],

    [ 3 * (loadavg.to_i + 1), %q{ kill_current_window()             }, ],
    [ 1 * (loadavg.to_i + 1), %q{ kill_kill_kill()                  }, ],
    [ 1 * (loadavg.to_i + 1), %q{ logout()                          }, ],
  ]

  commands_with_cumulative_probability = []
  sum = 0
  commands.each do |cmdinfo|
    commands_with_cumulative_probability << [ sum, cmdinfo[1] ]
    sum += cmdinfo[0]
  end

  cmd_string = get_random_command_string(sum,
					 commands_with_cumulative_probability)
  puts "puavo-autopilot-session is going to run #{ cmd_string.strip }"

  job = fork { eval(cmd_string) }
  Process.detach(job)

  # sleep a bit before doing more....
  # also slow down when system load rises (as users would do anyway)
  sleep(1  +  5 * Math.log(1 + loadavg) * rand())
end
